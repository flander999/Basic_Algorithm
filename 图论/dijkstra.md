# Dijkstra算法

## 朴素Dijkstra 

### 时间复杂度
$O(n^2)$，n表示节点数

### 使用场景
1. 没有负权边
2. 使用邻接矩阵作为储存图的数据结构

### 主要思想

1. 前期准备
  - dist 储存起始点到当前点的最短距离
  - S 当前已确定最短距离的点的集合
  - G\[]\[] 存储图的数据结构
2. 初始化
  - `dist[1] = 0; dist[i] = +INF`
3. for循环： i 从1~n
  - t <---不在S中的距离最近的点
  - 将t加入S
  - 用t更新其他点距离起始点的最近距离
    - `dist[j] = min(dist[j], dist[t]+g[t][j])`



## 堆优化版Dijkstra

### 时间复杂度

$$ O(m \log n)$$, n表示节点数，m表示边数

### 使用场景
1. 稀疏图
2. 无负权边
3. 使用邻接表

### 主要思想

1. 前期准备
  - dist 储存起始点到当前点的最短距离
  - S 当前已确定最短距离的点的集合
  - 邻接表 ----> 存储图的数据结构
2. 初始化
  - `dist[1] = 0; dist[i] = +INF`
3. for循环： i 从1~n
  - t <---不在S中的距离最近的点 **使用堆来查找**
    - 优化成 $$O(1)$$
  - 将t加入S
  - 用t更新其他点距离起始点的最近距离 **在堆中更新**
    - `dist[j] = min(dist[j], dist[t]+g[t][j])`
    - 优化成 $$ O(m \log n)$$
    - 手写堆比较繁琐，但是可以保证堆中最多只有n个数
    - 使用现有数据结构的堆(优先队列queue)，则使用冗余方法(堆中相同点距离可能存在冗余)



