# Bellman-ford算法

## 时间复杂度

$O(nm)$

## 应用场景

1. 单源最短路
2. 存在负权边
3. SPFA被故意卡的时候
4. 可以求是否存在负权回路(环)
  - 开辟`cnt[]`数组作为记录边数

## 主要思想

1. 前期准备
  - 存边方式：定义结构体，存储所有边
  - 定义`backup[]`数组，用于每次迭代之后的备份，防止出现一次迭代更新多个连接的点的最短距离。
2. 迭代n次 (从起始点开始，不超过n次位移的最短距离)
  - 循环所有边(a,b,w) ----> a到b，权重为w
  - 每到一条边，更新一下最短距离 `dist[b] = min(dist[b], dits[a]+w);`



# SPFA
对bellman-ford算法进行优化。

即，如果前一个点a没有被更新，则下一个点b也不会被更新。这种情况就可以被剪掉。

## 时间复杂度
理想状态下: $O(n)$
最坏情况下: $O(nm)$

## 应用场景


## 主要思想

1. 前期准备
  - 声明一个队列(queue), 存储前一次迭代被更新了的点(下一次迭代时，就取出这些点，一次更新相邻的下一个点)
  - 先将起点加入队列
2. 只要队列不空
  - 取出队头 t
  - 删掉队头 t
  - 遍历t的所有邻边，更新。(先判断邻边是否已在队列中)


## 检查是否存在负权回路

1. 定义cnt数组，记录每个点最短路径的步数
2. 每次更新最短路径时，更新步数，若步数超过节点数，则一定存在负权回路

**PS:** 此时，因为可能存在不已起始点为开头的负权回路，所以需要在迭代前，将所有的点加入队列，dist数组可以不再初始化。
